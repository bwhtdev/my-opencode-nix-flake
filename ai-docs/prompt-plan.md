# SourceCamp Prompt Plan

This document outlines a detailed, step-by-step blueprint for building SourceCamp Phase 1, broken into iterative chunks and actionable steps. It includes a series of prompts for a code-generation LLM to implement each step, ensuring incremental progress and integration.

## Blueprint for SourceCamp Phase 1

### Overview
- **Objective**: Build a modern Git hosting platform with core Git functionalities and secure user authentication.
- **Focus Areas**: Repository creation, cloning, committing, and secure passkey authentication.
- **Tech Stack**: Golang with Plush (backend templating), TypeScript with Vite (frontend serving backend-generated HTML), TailwindCSS, AlpineJS, PostgreSQL, Nix, Docker, Fly.io, Redis, RabbitMQ, Rive, pnpm for frontend package management.

### High-Level Steps
1. **Project Setup**: Initialize project structure, dependencies, and deployment configurations.
2. **Database Setup**: Configure PostgreSQL for user and repository data storage.
3. **Authentication System**: Implement secure passkey authentication using FIDO2/WebAuthn.
4. **Core Git Functionalities**: Develop repository creation, cloning, and committing features.
5. **Frontend Development**: Build intuitive UI with Vite serving HTML generated by Plush templates for user interaction with Git features and authentication.
6. **Error Handling**: Implement user-friendly error messages and logging.
7. **Testing**: Conduct unit, integration, security, and performance tests.
8. **Deployment**: Deploy the application using Docker and Fly.io.

## Iterative Chunks

### Chunk 1: Project Setup
- Initialize project structure with Golang backend using Plush for templating and TypeScript frontend with Vite.
- Set up version control with Git.
- Configure development environment with Vite, TailwindCSS, and AlpineJS to serve backend-generated HTML, using pnpm for package management.
- Define deployment strategy using Nix and Docker Compose for Fly.io.

### Chunk 2: Database Setup
- Set up PostgreSQL database with schemas for users and repositories.
- Implement secure data storage practices for user information and Git objects.

### Chunk 3: Authentication System
- Research and implement FIDO2/WebAuthn for passkey authentication.
- Develop user account creation with secure passkey storage.
- Ensure cross-browser and device compatibility.

### Chunk 4: Core Git Functionalities
- Build repository creation with configuration options (public/private, README).
- Implement cloning functionality for local and platform access.
- Develop committing interface with basic validation.

### Chunk 5: Frontend Development
- Create UI components for repository management and user authentication using Vite to serve HTML generated by Plush.
- Integrate frontend with backend APIs for Git operations.

### Chunk 6: Error Handling
- Design error feedback for authentication and Git operations.
- Set up secure logging for debugging without exposing sensitive data.

### Chunk 7: Testing
- Write unit tests for backend functions in Golang.
- Conduct integration tests for frontend-backend interactions.
- Perform security and performance testing.

### Chunk 8: Deployment
- Finalize Docker configurations for production.
- Deploy application to Fly.io with continuous integration setup.

## Actionable Steps

### Chunk 1: Project Setup
1.1. Create project directory structure for backend (Golang with Plush) and frontend (TypeScript with Vite).
1.2. Initialize Git repository and set up `.gitignore`.
1.3. Install dependencies for backend (Golang standard library, Plush) and frontend (Vite, TailwindCSS, AlpineJS) using pnpm.
1.4. Configure Nix for reproducible builds and Docker Compose for containerization.
1.5. Set up initial deployment scripts for Fly.io.

### Chunk 2: Database Setup
2.1. Install and configure PostgreSQL locally for development.
2.2. Design database schema for user data with encryption for sensitive fields.
2.3. Design schema for repository metadata and Git objects.
2.4. Write initial migration scripts for database setup.

### Chunk 3: Authentication System
3.1. Research FIDO2/WebAuthn standards and libraries for Golang.
3.2. Implement passkey registration endpoint in backend.
3.3. Implement passkey login endpoint with validation.
3.4. Create frontend forms for user registration and login with passkey support, served via Vite from Plush templates.
3.5. Test compatibility across major browsers and devices.

### Chunk 4: Core Git Functionalities
4.1. Develop backend API for repository creation with configuration options.
4.2. Implement cloning endpoint to handle repository access.
4.3. Build committing endpoint with message input and validation.
4.4. Integrate Git operations with PostgreSQL for metadata storage.

### Chunk 5: Frontend Development
5.1. Design UI layout for repository listing and creation, using Vite to serve Plush-generated HTML.
5.2. Create forms for committing changes with message input, integrated with backend via Vite-served HTML.
5.3. Build authentication UI for passkey registration and login, rendered by Plush and served by Vite.
5.4. Connect frontend to backend APIs using fetch or axios for dynamic interactions.

### Chunk 6: Error Handling
6.1. Define error messages for authentication failures.
6.2. Create user-friendly messages for Git operation failures.
6.3. Implement generic error page/modal for unexpected issues, rendered via Plush templates.
6.4. Set up backend logging for detailed error tracking.

### Chunk 7: Testing
7.1. Write unit tests for Golang backend functions (repository operations, authentication).
7.2. Develop integration tests for API endpoints and frontend interactions via Vite-served HTML.
7.3. Conduct security tests for passkey authentication.
7.4. Perform initial performance benchmarks for Git operations.

### Chunk 8: Deployment
8.1. Finalize Docker Compose configuration for production environment.
8.2. Test deployment locally with Docker.
8.3. Deploy to Fly.io with initial setup for scalability.
8.4. Configure monitoring and logging on Fly.io.

## LLM Prompts for Implementation

### Prompt 1: Project Setup - Directory Structure and Git
```text
Initialize a project structure for SourceCamp with a Golang backend using Plush for templating and TypeScript frontend with Vite. Create directories for backend (src/backend) and frontend (src/frontend). Set up a Git repository with a comprehensive .gitignore file for Golang and Node.js projects. Ensure the structure supports separate environments for development and production.
```

### Prompt 2: Project Setup - Dependencies
```text
Install necessary dependencies for SourceCamp. For the backend, use Golang's standard library for HTTP servers and Plush (github.com/gobuffalo/plush) for HTML templating. For the frontend, set up a Vite project with TypeScript, TailwindCSS for styling, and AlpineJS for interactivity to serve backend-generated HTML, using pnpm as the package manager. Provide scripts to install and verify dependencies in both environments.
```

### Prompt 3: Project Setup - Deployment Configuration
```text
Configure Nix for reproducible builds and Docker Compose for containerization targeting Fly.io. Create a basic Nix flake for dependency management and a Docker Compose file defining services for backend, frontend, and database. Ensure configurations support development and production environments with Vite serving Plush-generated HTML.
```

### Prompt 4: Database Setup - PostgreSQL Configuration
```text
Set up PostgreSQL for SourceCamp. Provide instructions to install and configure PostgreSQL locally for development. Create a basic database initialization script to set up the SourceCamp database with necessary permissions and extensions for user and repository data.
```

### Prompt 5: Database Setup - Schema Design for Users
```text
Design a PostgreSQL schema for user data in SourceCamp. Include tables for user information with fields for ID, username, email, and encrypted passkey data. Ensure compliance with data protection regulations like GDPR by implementing encryption for sensitive fields. Provide SQL scripts for table creation and initial data insertion.
```

### Prompt 6: Database Setup - Schema Design for Repositories
```text
Design a PostgreSQL schema for repository data in SourceCamp. Include tables for repository metadata (ID, name, owner, visibility) and Git objects. Optimize storage for quick access and scalability. Provide SQL scripts for creating these tables and linking them to user data.
```

### Prompt 7: Authentication System - Research FIDO2/WebAuthn
```text
Research and summarize the implementation of FIDO2/WebAuthn for passkey authentication in a Golang backend. Identify suitable libraries and outline steps to integrate passkey registration and login. Focus on security best practices and compatibility with major browsers and devices.
```

### Prompt 8: Authentication System - Backend Registration Endpoint
```text
Implement a backend endpoint in Golang for passkey registration using FIDO2/WebAuthn. Create a RESTful API endpoint that handles passkey creation, securely stores passkey data in PostgreSQL, and returns necessary responses for frontend integration. Ensure the endpoint follows functional programming principles.
```

### Prompt 9: Authentication System - Backend Login Endpoint
```text
Implement a backend endpoint in Golang for passkey login using FIDO2/WebAuthn. Develop a RESTful API endpoint to validate passkey credentials against stored data in PostgreSQL. Return appropriate success or error responses for frontend handling, adhering to functional programming practices.
```

### Prompt 10: Authentication System - Frontend Forms
```text
Develop frontend forms in TypeScript using Vite for user registration and login with passkey support. Use TailwindCSS for styling and AlpineJS for interactivity. Ensure forms are rendered via Plush templates on the backend and served by Vite, communicating with backend endpoints for passkey registration and authentication, providing user feedback on success or failure.
```

### Prompt 11: Core Git Functionalities - Repository Creation API
```text
Build a backend API in Golang for repository creation in SourceCamp. Implement a RESTful endpoint that allows users to create repositories with options for visibility (public/private) and README initialization. Store repository metadata in PostgreSQL and return relevant data for frontend display via Plush templates.
```

### Prompt 12: Core Git Functionalities - Cloning Endpoint
```text
Implement a backend endpoint in Golang for cloning repositories in SourceCamp. Create an API that supports cloning to local environments or within the platform. Ensure integration with PostgreSQL for access control and metadata retrieval, returning necessary data for user access via Plush-generated HTML.
```

### Prompt 13: Core Git Functionalities - Committing Endpoint
```text
Develop a backend endpoint in Golang for committing changes in SourceCamp. Build a RESTful API that accepts commit messages and performs basic validation before storing changes in the repository. Integrate with PostgreSQL for metadata updates and return success or error responses for frontend rendering via Plush.
```

### Prompt 14: Frontend Development - Repository UI
```text
Design and implement UI components in TypeScript for repository management in SourceCamp. Create pages for listing repositories and creating new ones using TailwindCSS for styling. Ensure the UI is rendered by Plush templates on the backend and served by Vite, connecting to backend APIs to fetch and display repository data for a seamless user experience.
```

### Prompt 15: Frontend Development - Commit Interface
```text
Create a frontend interface in TypeScript for committing changes in SourceCamp. Develop a form for entering commit messages, styled with TailwindCSS, and use AlpineJS for dynamic behavior. Ensure the form is rendered via Plush templates and served by Vite, integrating with the backend commit endpoint to submit changes and display feedback.
```

### Prompt 16: Error Handling - Authentication Errors
```text
Implement error handling for authentication failures in SourceCamp. Define specific error messages for passkey issues (e.g., 'Invalid passkey') in both backend (Golang) and frontend (TypeScript). Ensure messages are user-friendly, rendered via Plush templates, and logs are secure without exposing sensitive data.
```

### Prompt 17: Error Handling - Git Operation Errors
```text
Develop error handling for Git operation failures in SourceCamp. Create user-friendly messages for failed operations (e.g., 'Failed to commit: no changes detected') in backend and frontend. Ensure messages are rendered via Plush templates and served by Vite, with secure logging in Golang for debugging purposes without revealing sensitive information.
```

### Prompt 18: Testing - Unit Tests for Backend
```text
Write unit tests in Golang for backend functions in SourceCamp. Focus on testing repository operations (creation, cloning, committing) and authentication logic (passkey registration, login). Ensure tests cover edge cases and follow functional programming principles.
```

### Prompt 19: Testing - Integration Tests
```text
Develop integration tests for SourceCamp to validate frontend-backend interactions. Test API endpoints for Git operations and authentication, ensuring data flows correctly between TypeScript frontend (served by Vite from Plush templates) and Golang backend. Provide scripts to run these tests in a development environment.
```

### Prompt 20: Deployment - Docker Configuration
```text
Finalize Docker Compose configuration for SourceCamp's production environment. Define services for backend, frontend (Vite serving Plush-generated HTML), PostgreSQL, Redis, and RabbitMQ. Ensure configurations support scalability and integrate with Fly.io deployment scripts for seamless production deployment.
```

### Prompt 21: Deployment - Deploy to Fly.io
```text
Deploy SourceCamp to Fly.io. Provide step-by-step instructions to test deployment locally with Docker, then push to Fly.io. Configure initial settings for scalability, monitoring, and logging on Fly.io to ensure the application, with Vite serving Plush-generated HTML, runs smoothly in production.
```

## Notes
- Each prompt builds on the previous one, ensuring no orphaned code and full integration at each step.
- Prompts adhere to best practices, focusing on incremental progress without significant jumps in complexity.
- The sequence ensures that by the final prompt, all components are wired together into a functional Phase 1 application.
